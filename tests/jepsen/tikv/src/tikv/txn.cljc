;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package tikv.txn
;;;----------------------------------------------------------------------------------
(ns tikv.txn
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [tikv.error :as tikv.error]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->BeginTxnReply)
(declare ecis->BeginTxnReply)
(declare new-BeginTxnReply)
(declare cis->GetRequest)
(declare ecis->GetRequest)
(declare new-GetRequest)
(declare cis->RollbackRequest)
(declare ecis->RollbackRequest)
(declare new-RollbackRequest)
(declare cis->CommitRequest)
(declare ecis->CommitRequest)
(declare new-CommitRequest)
(declare cis->PutRequest)
(declare ecis->PutRequest)
(declare new-PutRequest)
(declare cis->RollbackReply)
(declare ecis->RollbackReply)
(declare new-RollbackReply)
(declare cis->GetReply)
(declare ecis->GetReply)
(declare new-GetReply)
(declare cis->BeginTxnRequest)
(declare ecis->BeginTxnRequest)
(declare new-BeginTxnRequest)
(declare cis->CommitReply)
(declare ecis->CommitReply)
(declare new-CommitReply)
(declare cis->PutReply)
(declare ecis->PutReply)
(declare new-PutReply)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; BeginTxnRequest-Type
;-----------------------------------------------------------------------------
(def BeginTxnRequest-Type-val2label {
  0 :optimistic
  1 :pessimistic})

(def BeginTxnRequest-Type-label2val (set/map-invert BeginTxnRequest-Type-val2label))

(defn cis->BeginTxnRequest-Type [is]
  (let [val (serdes.core/cis->Enum is)]
    (get BeginTxnRequest-Type-val2label val val)))

(defn- get-BeginTxnRequest-Type [value]
  {:pre [(or (int? value) (contains? BeginTxnRequest-Type-label2val value))]}
  (get BeginTxnRequest-Type-label2val value value))

(defn write-BeginTxnRequest-Type
  ([tag value os] (write-BeginTxnRequest-Type tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-BeginTxnRequest-Type value) os)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; BeginTxnReply
;-----------------------------------------------------------------------------
(defrecord BeginTxnReply-record [txn-id error]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Fixed32 1  {:optimize true} (:txn-id this) os)
    (serdes.core/write-embedded 2 (:error this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.BeginTxnReply"))

(s/def :tikv.txn.BeginTxnReply/txn-id int?)

(s/def ::BeginTxnReply-spec (s/keys :opt-un [:tikv.txn.BeginTxnReply/txn-id ]))
(def BeginTxnReply-defaults {:txn-id 0 })

(defn cis->BeginTxnReply
  "CodedInputStream to BeginTxnReply"
  [is]
  (->> (tag-map BeginTxnReply-defaults
         (fn [tag index]
             (case index
               1 [:txn-id (serdes.core/cis->Fixed32 is)]
               2 [:error (tikv.error/ecis->Error is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BeginTxnReply-record)))

(defn ecis->BeginTxnReply
  "Embedded CodedInputStream to BeginTxnReply"
  [is]
  (serdes.core/cis->embedded cis->BeginTxnReply is))

(defn new-BeginTxnReply
  "Creates a new instance from a map, similar to map->BeginTxnReply except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BeginTxnReply-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BeginTxnReply-spec init))))]}
  (-> (merge BeginTxnReply-defaults init)
      (cond-> (some? (get init :error)) (update :error tikv.error/new-Error))
      (map->BeginTxnReply-record)))

(defn pb->BeginTxnReply
  "Protobuf to BeginTxnReply"
  [input]
  (cis->BeginTxnReply (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BeginTxnReply-meta {:type "tikv.txn.BeginTxnReply" :decoder pb->BeginTxnReply})

;-----------------------------------------------------------------------------
; GetRequest
;-----------------------------------------------------------------------------
(defrecord GetRequest-record [txn-id key]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Fixed32 1  {:optimize true} (:txn-id this) os)
    (serdes.core/write-String 2  {:optimize true} (:key this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.GetRequest"))

(s/def :tikv.txn.GetRequest/txn-id int?)
(s/def :tikv.txn.GetRequest/key string?)
(s/def ::GetRequest-spec (s/keys :opt-un [:tikv.txn.GetRequest/txn-id :tikv.txn.GetRequest/key ]))
(def GetRequest-defaults {:txn-id 0 :key "" })

(defn cis->GetRequest
  "CodedInputStream to GetRequest"
  [is]
  (->> (tag-map GetRequest-defaults
         (fn [tag index]
             (case index
               1 [:txn-id (serdes.core/cis->Fixed32 is)]
               2 [:key (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->GetRequest-record)))

(defn ecis->GetRequest
  "Embedded CodedInputStream to GetRequest"
  [is]
  (serdes.core/cis->embedded cis->GetRequest is))

(defn new-GetRequest
  "Creates a new instance from a map, similar to map->GetRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GetRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GetRequest-spec init))))]}
  (-> (merge GetRequest-defaults init)
      (map->GetRequest-record)))

(defn pb->GetRequest
  "Protobuf to GetRequest"
  [input]
  (cis->GetRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record GetRequest-meta {:type "tikv.txn.GetRequest" :decoder pb->GetRequest})

;-----------------------------------------------------------------------------
; RollbackRequest
;-----------------------------------------------------------------------------
(defrecord RollbackRequest-record [txn-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Fixed32 1  {:optimize true} (:txn-id this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.RollbackRequest"))

(s/def :tikv.txn.RollbackRequest/txn-id int?)
(s/def ::RollbackRequest-spec (s/keys :opt-un [:tikv.txn.RollbackRequest/txn-id ]))
(def RollbackRequest-defaults {:txn-id 0 })

(defn cis->RollbackRequest
  "CodedInputStream to RollbackRequest"
  [is]
  (->> (tag-map RollbackRequest-defaults
         (fn [tag index]
             (case index
               1 [:txn-id (serdes.core/cis->Fixed32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RollbackRequest-record)))

(defn ecis->RollbackRequest
  "Embedded CodedInputStream to RollbackRequest"
  [is]
  (serdes.core/cis->embedded cis->RollbackRequest is))

(defn new-RollbackRequest
  "Creates a new instance from a map, similar to map->RollbackRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RollbackRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RollbackRequest-spec init))))]}
  (-> (merge RollbackRequest-defaults init)
      (map->RollbackRequest-record)))

(defn pb->RollbackRequest
  "Protobuf to RollbackRequest"
  [input]
  (cis->RollbackRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RollbackRequest-meta {:type "tikv.txn.RollbackRequest" :decoder pb->RollbackRequest})

;-----------------------------------------------------------------------------
; CommitRequest
;-----------------------------------------------------------------------------
(defrecord CommitRequest-record [txn-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Fixed32 1  {:optimize true} (:txn-id this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.CommitRequest"))

(s/def :tikv.txn.CommitRequest/txn-id int?)
(s/def ::CommitRequest-spec (s/keys :opt-un [:tikv.txn.CommitRequest/txn-id ]))
(def CommitRequest-defaults {:txn-id 0 })

(defn cis->CommitRequest
  "CodedInputStream to CommitRequest"
  [is]
  (->> (tag-map CommitRequest-defaults
         (fn [tag index]
             (case index
               1 [:txn-id (serdes.core/cis->Fixed32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CommitRequest-record)))

(defn ecis->CommitRequest
  "Embedded CodedInputStream to CommitRequest"
  [is]
  (serdes.core/cis->embedded cis->CommitRequest is))

(defn new-CommitRequest
  "Creates a new instance from a map, similar to map->CommitRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CommitRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CommitRequest-spec init))))]}
  (-> (merge CommitRequest-defaults init)
      (map->CommitRequest-record)))

(defn pb->CommitRequest
  "Protobuf to CommitRequest"
  [input]
  (cis->CommitRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CommitRequest-meta {:type "tikv.txn.CommitRequest" :decoder pb->CommitRequest})

;-----------------------------------------------------------------------------
; PutRequest
;-----------------------------------------------------------------------------
(defrecord PutRequest-record [txn-id key value]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Fixed32 1  {:optimize true} (:txn-id this) os)
    (serdes.core/write-String 2  {:optimize true} (:key this) os)
    (serdes.core/write-String 3  {:optimize true} (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.PutRequest"))

(s/def :tikv.txn.PutRequest/txn-id int?)
(s/def :tikv.txn.PutRequest/key string?)
(s/def :tikv.txn.PutRequest/value string?)
(s/def ::PutRequest-spec (s/keys :opt-un [:tikv.txn.PutRequest/txn-id :tikv.txn.PutRequest/key :tikv.txn.PutRequest/value ]))
(def PutRequest-defaults {:txn-id 0 :key "" :value "" })

(defn cis->PutRequest
  "CodedInputStream to PutRequest"
  [is]
  (->> (tag-map PutRequest-defaults
         (fn [tag index]
             (case index
               1 [:txn-id (serdes.core/cis->Fixed32 is)]
               2 [:key (serdes.core/cis->String is)]
               3 [:value (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->PutRequest-record)))

(defn ecis->PutRequest
  "Embedded CodedInputStream to PutRequest"
  [is]
  (serdes.core/cis->embedded cis->PutRequest is))

(defn new-PutRequest
  "Creates a new instance from a map, similar to map->PutRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PutRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PutRequest-spec init))))]}
  (-> (merge PutRequest-defaults init)
      (map->PutRequest-record)))

(defn pb->PutRequest
  "Protobuf to PutRequest"
  [input]
  (cis->PutRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PutRequest-meta {:type "tikv.txn.PutRequest" :decoder pb->PutRequest})

;-----------------------------------------------------------------------------
; RollbackReply
;-----------------------------------------------------------------------------
(defrecord RollbackReply-record [error]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:error this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.RollbackReply"))

(s/def ::RollbackReply-spec (s/keys :opt-un []))
(def RollbackReply-defaults {})

(defn cis->RollbackReply
  "CodedInputStream to RollbackReply"
  [is]
  (->> (tag-map RollbackReply-defaults
         (fn [tag index]
             (case index
               1 [:error (tikv.error/ecis->Error is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RollbackReply-record)))

(defn ecis->RollbackReply
  "Embedded CodedInputStream to RollbackReply"
  [is]
  (serdes.core/cis->embedded cis->RollbackReply is))

(defn new-RollbackReply
  "Creates a new instance from a map, similar to map->RollbackReply except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RollbackReply-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RollbackReply-spec init))))]}
  (-> (merge RollbackReply-defaults init)
      (cond-> (some? (get init :error)) (update :error tikv.error/new-Error))
      (map->RollbackReply-record)))

(defn pb->RollbackReply
  "Protobuf to RollbackReply"
  [input]
  (cis->RollbackReply (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RollbackReply-meta {:type "tikv.txn.RollbackReply" :decoder pb->RollbackReply})

;-----------------------------------------------------------------------------
; GetReply
;-----------------------------------------------------------------------------
(defrecord GetReply-record [value error]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:value this) os)
    (serdes.core/write-embedded 2 (:error this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.GetReply"))

(s/def :tikv.txn.GetReply/value string?)

(s/def ::GetReply-spec (s/keys :opt-un [:tikv.txn.GetReply/value ]))
(def GetReply-defaults {:value "" })

(defn cis->GetReply
  "CodedInputStream to GetReply"
  [is]
  (->> (tag-map GetReply-defaults
         (fn [tag index]
             (case index
               1 [:value (serdes.core/cis->String is)]
               2 [:error (tikv.error/ecis->Error is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->GetReply-record)))

(defn ecis->GetReply
  "Embedded CodedInputStream to GetReply"
  [is]
  (serdes.core/cis->embedded cis->GetReply is))

(defn new-GetReply
  "Creates a new instance from a map, similar to map->GetReply except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GetReply-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GetReply-spec init))))]}
  (-> (merge GetReply-defaults init)
      (cond-> (some? (get init :error)) (update :error tikv.error/new-Error))
      (map->GetReply-record)))

(defn pb->GetReply
  "Protobuf to GetReply"
  [input]
  (cis->GetReply (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record GetReply-meta {:type "tikv.txn.GetReply" :decoder pb->GetReply})

;-----------------------------------------------------------------------------
; BeginTxnRequest
;-----------------------------------------------------------------------------
(defrecord BeginTxnRequest-record [type]
  pb/Writer
  (serialize [this os]
    (write-BeginTxnRequest-Type 1  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.BeginTxnRequest"))

(s/def :tikv.txn.BeginTxnRequest/type (s/or :keyword keyword? :int int?))
(s/def ::BeginTxnRequest-spec (s/keys :opt-un [:tikv.txn.BeginTxnRequest/type ]))
(def BeginTxnRequest-defaults {:type (BeginTxnRequest-Type-val2label 0) })

(defn cis->BeginTxnRequest
  "CodedInputStream to BeginTxnRequest"
  [is]
  (->> (tag-map BeginTxnRequest-defaults
         (fn [tag index]
             (case index
               1 [:type (cis->BeginTxnRequest-Type is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BeginTxnRequest-record)))

(defn ecis->BeginTxnRequest
  "Embedded CodedInputStream to BeginTxnRequest"
  [is]
  (serdes.core/cis->embedded cis->BeginTxnRequest is))

(defn new-BeginTxnRequest
  "Creates a new instance from a map, similar to map->BeginTxnRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BeginTxnRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BeginTxnRequest-spec init))))]}
  (-> (merge BeginTxnRequest-defaults init)
      (map->BeginTxnRequest-record)))

(defn pb->BeginTxnRequest
  "Protobuf to BeginTxnRequest"
  [input]
  (cis->BeginTxnRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BeginTxnRequest-meta {:type "tikv.txn.BeginTxnRequest" :decoder pb->BeginTxnRequest})

;-----------------------------------------------------------------------------
; CommitReply
;-----------------------------------------------------------------------------
(defrecord CommitReply-record [error]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:error this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.CommitReply"))

(s/def ::CommitReply-spec (s/keys :opt-un []))
(def CommitReply-defaults {})

(defn cis->CommitReply
  "CodedInputStream to CommitReply"
  [is]
  (->> (tag-map CommitReply-defaults
         (fn [tag index]
             (case index
               1 [:error (tikv.error/ecis->Error is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CommitReply-record)))

(defn ecis->CommitReply
  "Embedded CodedInputStream to CommitReply"
  [is]
  (serdes.core/cis->embedded cis->CommitReply is))

(defn new-CommitReply
  "Creates a new instance from a map, similar to map->CommitReply except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CommitReply-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CommitReply-spec init))))]}
  (-> (merge CommitReply-defaults init)
      (cond-> (some? (get init :error)) (update :error tikv.error/new-Error))
      (map->CommitReply-record)))

(defn pb->CommitReply
  "Protobuf to CommitReply"
  [input]
  (cis->CommitReply (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CommitReply-meta {:type "tikv.txn.CommitReply" :decoder pb->CommitReply})

;-----------------------------------------------------------------------------
; PutReply
;-----------------------------------------------------------------------------
(defrecord PutReply-record [error]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:error this) os))
  pb/TypeReflection
  (gettype [this]
    "tikv.txn.PutReply"))

(s/def ::PutReply-spec (s/keys :opt-un []))
(def PutReply-defaults {})

(defn cis->PutReply
  "CodedInputStream to PutReply"
  [is]
  (->> (tag-map PutReply-defaults
         (fn [tag index]
             (case index
               1 [:error (tikv.error/ecis->Error is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->PutReply-record)))

(defn ecis->PutReply
  "Embedded CodedInputStream to PutReply"
  [is]
  (serdes.core/cis->embedded cis->PutReply is))

(defn new-PutReply
  "Creates a new instance from a map, similar to map->PutReply except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PutReply-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PutReply-spec init))))]}
  (-> (merge PutReply-defaults init)
      (cond-> (some? (get init :error)) (update :error tikv.error/new-Error))
      (map->PutReply-record)))

(defn pb->PutReply
  "Protobuf to PutReply"
  [input]
  (cis->PutReply (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PutReply-meta {:type "tikv.txn.PutReply" :decoder pb->PutReply})

